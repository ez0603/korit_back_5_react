// 클라이언트 -> 서버 요청 -> 서버의 응답 -> 클라이언트
// 함수 = 정의, 호출 영역 따로 존재

클라이언트_화면_출력(); // 함수 호출

function 클라이언트_화면_출력() { // html 화면 / 함수 정의
    
    let a = 클라이언트_데이터_입력(10); // 자바스크립트 = 데이터에 값이 대입되었을 때 타입이 결정됨 <-> 타입스크립트 = 정의가 되어있어야함
    let b = 클라이언트_데이터_입력(20);
    // 클라이언트_데이터_입력({num: 10, name:"김준일"}); -> 타입스크립트, 객체가 들어왔을 때

    let 요청데이터 = { // 객체 = 여러개의 변수를 하나의 변수로 묶음
        데이터1: a,
        데이터2: b
    };

    // 함수안에 함수를 정의해주면 같은 메모리 공간안에 있기때문에 매개변수로 받지 않고도 쓸 수 있다/ 매개변수 = 지역
    const test = () => {  // 하나의 function 안에서는 function 쓰지 않고 익명함수, 화살표함수로 정의
        let c = 30; 
        return 요청데이터;
    }

    // 요청데이터. // 데이터1, 데이터2를 쓰려면 요청데이터. 을 하면 쓰기 가능 
    클라이언트_데이터_삽입_요청_버튼_클릭(test()); // (function test() {}) -> 함수를 매개변수 전달 가능, 정의전달 <-> 호출전달 , 정의 자체도 값이기 때문에 전달 가능

}

// interface student { -> 타입스크립트, 객체를 정의해주기 위해 interface
//     num: number,
//     name: string
// }

// input
function 클라이언트_데이터_입력(데이터) { // 데이터를 받을 수 있는 공간 = 매개변수 / (데이터: string): string => 타입스크립트, 자료형을 뒤에 적어줌 (함수의 끝에 정의), 끝은 항상 string
    // function 클라이언트_데이터_입력(데이터: student): student -> 타입스크립트, interface를 만들어서 받아줌
    return 데이터;
    // return
    // 1. 비어있는 리턴 = 탈출(함수를 빠져나가게 하는 리턴) 리턴 자료형 X(void) - undefind
    // 2. 값이 있는 리턴
    // 리턴이 있으면 함수 자체가 값
}

function 클라이언트_데이터_삽입_요청_버튼_클릭(요청데이터) {
    백엔드_데이터_삽입_요청(요청데이터);
}

function 백엔드_데이터_삽입_요청(요청데이터) {
    console.log(요청데이터);
    console.log("요청");
}

// function = 제일 마지막에 해야할 것을 생각 한 뒤 루트 짜기

//------------------------------------------------------------------------------------------ 
// let a = 10;
// let b = 20;
// let result = a + b; // 대입하기 위해서는 선언을 먼저 해줘야함

// stack에서 쌓이는 순서
// a정의
// a=10;
// b정의
// b=20;
// a+b
// let result
// result -> 마지막
//------------------------------------------------------------------------------------------